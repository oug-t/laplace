import * as THREE from "three";
// 1. Import OrbitControls
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

import { TimeController } from "../core/TimeController";
import { GraphManager } from "./GraphManager";
import { BackgroundShader } from "./components/BackgroundShader";
import { createStarfield } from "./components/Starfield";
import { BattleManager } from "../core/BattleManager";

export class SceneManager {
    public scene: THREE.Scene;
    public camera: THREE.PerspectiveCamera;
    public renderer: THREE.WebGLRenderer;
    public controls: OrbitControls; // 2. Add property

    private graphMgr: GraphManager;
    private backgroundShader: BackgroundShader;
    private battleMgr: BattleManager;
    private raycaster: THREE.Raycaster;
    private mouse: THREE.Vector2;

    constructor(container: HTMLElement) {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);

        // 1. Camera Setup
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.position.set(20, 15, 40); // Initial "Tactical View"
        this.camera.lookAt(0, 0, 0);

        // 2. Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(this.renderer.domElement);

        // 3. CONTROLS (The EVE Feel)
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        
        // Damping: Gives the camera "weight". It doesn't stop instantly.
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        
        // Pan: Allow moving the camera target (Right-click drag default)
        this.controls.enablePan = true;
        this.controls.screenSpacePanning = true; // True = Pan like an RTS (flat). False = Pan relative to camera angle.
        
        // Limits: Don't let them zoom infinitely close or far
        this.controls.minDistance = 2;
        this.controls.maxDistance = 200;

        // Optional: Remap Mouse Buttons if you prefer EVE style
        // Default is: LEFT=Rotate, MIDDLE=Zoom, RIGHT=Pan
        // We can keep defaults or swap them:
        this.controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        // 4. Environment
        this.backgroundShader = new BackgroundShader();
        this.scene.add(this.backgroundShader.mesh);
        
        const starfield = createStarfield(4000);
        this.scene.add(starfield);

        // 5. Systems
        this.graphMgr = new GraphManager();
        this.scene.add(this.graphMgr.group);

        this.battleMgr = new BattleManager();
        this.scene.add(this.battleMgr.group);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 50, 50);
        this.scene.add(sunLight);
        this.scene.add(new THREE.AmbientLight(0x404040, 2.0));

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        
        window.addEventListener("resize", () => this.onWindowResize());
    }

    public render(timeCtrl: TimeController) {
        // IMPORTANT: Update controls every frame for Damping to work
        this.controls.update();

        this.graphMgr.update(timeCtrl.currentYear);
        if (this.battleMgr) this.battleMgr.update(timeCtrl.currentYear);

        this.renderer.render(this.scene, this.camera);
    }
    
    // ... (Keep existing onWindowResize and interaction methods)
    private onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}
